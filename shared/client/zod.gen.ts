// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod/v4';

export const zBookmarkId = z.string();

export const zListId = z.string();

export const zTagId = z.string();

export const zHighlightId = z.string();

export const zAssetId = z.string();

export const zBookmark = z.object({
    id: z.string(),
    createdAt: z.string(),
    modifiedAt: z.union([
        z.string(),
        z.null()
    ]),
    title: z.union([
        z.string(),
        z.null()
    ]).optional(),
    archived: z.boolean(),
    favourited: z.boolean(),
    taggingStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    summarizationStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    note: z.union([
        z.string(),
        z.null()
    ]).optional(),
    summary: z.union([
        z.string(),
        z.null()
    ]).optional(),
    tags: z.array(z.object({
        id: z.string(),
        name: z.string(),
        attachedBy: z.enum([
            'ai',
            'human'
        ])
    })),
    content: z.union([
        z.object({
            type: z.enum([
                'link'
            ]),
            url: z.string(),
            title: z.union([
                z.string(),
                z.null()
            ]).optional(),
            description: z.union([
                z.string(),
                z.null()
            ]).optional(),
            imageUrl: z.union([
                z.string(),
                z.null()
            ]).optional(),
            imageAssetId: z.union([
                z.string(),
                z.null()
            ]).optional(),
            screenshotAssetId: z.union([
                z.string(),
                z.null()
            ]).optional(),
            fullPageArchiveAssetId: z.union([
                z.string(),
                z.null()
            ]).optional(),
            precrawledArchiveAssetId: z.union([
                z.string(),
                z.null()
            ]).optional(),
            videoAssetId: z.union([
                z.string(),
                z.null()
            ]).optional(),
            favicon: z.union([
                z.string(),
                z.null()
            ]).optional(),
            htmlContent: z.union([
                z.string(),
                z.null()
            ]).optional(),
            crawledAt: z.union([
                z.string(),
                z.null()
            ]).optional(),
            author: z.union([
                z.string(),
                z.null()
            ]).optional(),
            publisher: z.union([
                z.string(),
                z.null()
            ]).optional(),
            datePublished: z.union([
                z.string(),
                z.null()
            ]).optional(),
            dateModified: z.union([
                z.string(),
                z.null()
            ]).optional()
        }),
        z.object({
            type: z.enum([
                'text'
            ]),
            text: z.string(),
            sourceUrl: z.union([
                z.string(),
                z.null()
            ]).optional()
        }),
        z.object({
            type: z.enum([
                'asset'
            ]),
            assetType: z.enum([
                'image',
                'pdf'
            ]),
            assetId: z.string(),
            fileName: z.union([
                z.string(),
                z.null()
            ]).optional(),
            sourceUrl: z.union([
                z.string(),
                z.null()
            ]).optional(),
            size: z.union([
                z.number(),
                z.null()
            ]).optional(),
            content: z.union([
                z.string(),
                z.null()
            ]).optional()
        }),
        z.object({
            type: z.enum([
                'unknown'
            ])
        })
    ]),
    assets: z.array(z.object({
        id: z.string(),
        assetType: z.enum([
            'screenshot',
            'assetScreenshot',
            'bannerImage',
            'fullPageArchive',
            'video',
            'bookmarkAsset',
            'precrawledArchive',
            'unknown'
        ])
    }))
});

export const zPaginatedBookmarks = z.object({
    bookmarks: z.array(zBookmark),
    nextCursor: z.union([
        z.string(),
        z.null()
    ])
});

export const zCursor = z.string();

export const zHighlight = z.object({
    bookmarkId: z.string(),
    startOffset: z.number(),
    endOffset: z.number(),
    color: z.enum([
        'yellow',
        'red',
        'green',
        'blue'
    ]).optional(),
    text: z.union([
        z.string(),
        z.null()
    ]),
    note: z.union([
        z.string(),
        z.null()
    ]),
    id: z.string(),
    userId: z.string(),
    createdAt: z.string()
});

export const zList = z.object({
    id: z.string(),
    name: z.string(),
    description: z.union([
        z.string(),
        z.null()
    ]).optional(),
    icon: z.string(),
    parentId: z.union([
        z.string(),
        z.null()
    ]),
    type: z.enum([
        'manual',
        'smart'
    ]).optional(),
    query: z.union([
        z.string(),
        z.null()
    ]).optional(),
    public: z.boolean()
});

export const zTag = z.object({
    id: z.string(),
    name: z.string(),
    numBookmarks: z.number(),
    numBookmarksByAttachedType: z.object({
        ai: z.number().optional(),
        human: z.number().optional()
    })
});

export const zPaginatedHighlights = z.object({
    highlights: z.array(zHighlight),
    nextCursor: z.union([
        z.string(),
        z.null()
    ])
});

export const zAsset = z.object({
    assetId: z.string(),
    contentType: z.string(),
    size: z.number(),
    fileName: z.string()
});

export const zFileToBeUploaded = z.unknown();

export const zBookmarkId2 = zBookmarkId;

export const zListId2 = zListId;

export const zTagId2 = zTagId;

export const zHighlightId2 = zHighlightId;

export const zAssetId2 = zAssetId;

export const zGetBookmarksParameterArchived = z.boolean();

export const zGetBookmarksParameterFavourited = z.boolean();

export const zGetBookmarksParameterSortOrder = z.enum([
    'asc',
    'desc'
]);

export const zGetBookmarksParameterLimit = z.number();

export const zGetBookmarksParameterCursor = zCursor;

/**
 * If set to true, bookmark's content will be included in the response. Note, this content can be large for some bookmarks.
 */
export const zGetBookmarksParameterIncludeContent = z.boolean().default(true);

/**
 * Object with all bookmarks data.
 */
export const zGetBookmarksResponse = zPaginatedBookmarks;

/**
 * The bookmark to create
 */
export const zPostBookmarksData = z.object({
    title: z.union([
        z.string().max(1000),
        z.null()
    ]).optional(),
    archived: z.boolean().optional(),
    favourited: z.boolean().optional(),
    note: z.string().optional(),
    summary: z.string().optional(),
    createdAt: z.union([
        z.string(),
        z.null()
    ]).optional()
}).and(z.union([
    z.object({
        type: z.enum([
            'link'
        ]),
        url: z.string().url(),
        precrawledArchiveId: z.string().optional()
    }),
    z.object({
        type: z.enum([
            'text'
        ]),
        text: z.string(),
        sourceUrl: z.string().optional()
    }),
    z.object({
        type: z.enum([
            'asset'
        ]),
        assetType: z.enum([
            'image',
            'pdf'
        ]),
        assetId: z.string(),
        fileName: z.string().optional(),
        sourceUrl: z.string().optional()
    })
]));

/**
 * The created bookmark
 */
export const zPostBookmarksResponse = zBookmark;

export const zGetBookmarksSearchParameterQ = z.string();

export const zGetBookmarksSearchParameterSortOrder = z.enum([
    'asc',
    'desc',
    'relevance'
]);

export const zGetBookmarksSearchParameterLimit = z.number();

export const zGetBookmarksSearchParameterCursor = zCursor;

/**
 * If set to true, bookmark's content will be included in the response. Note, this content can be large for some bookmarks.
 */
export const zGetBookmarksSearchParameterIncludeContent = z.boolean().default(true);

/**
 * Object with the search results.
 */
export const zGetBookmarksSearchResponse = zPaginatedBookmarks;

export const zDeleteBookmarksByBookmarkIdParameterBookmarkId = zBookmarkId;

/**
 * No content - the bookmark was deleted
 */
export const zDeleteBookmarksByBookmarkIdResponse = z.void();

export const zGetBookmarksByBookmarkIdParameterBookmarkId = zBookmarkId;

/**
 * If set to true, bookmark's content will be included in the response. Note, this content can be large for some bookmarks.
 */
export const zGetBookmarksByBookmarkIdParameterIncludeContent = z.boolean().default(true);

/**
 * Object with bookmark data.
 */
export const zGetBookmarksByBookmarkIdResponse = zBookmark;

/**
 * The data to update. Only the fields you want to update need to be provided.
 */
export const zPatchBookmarksByBookmarkIdData = z.object({
    archived: z.boolean().optional(),
    favourited: z.boolean().optional(),
    summary: z.union([
        z.string(),
        z.null()
    ]).optional(),
    note: z.string().optional(),
    title: z.union([
        z.string().max(1000),
        z.null()
    ]).optional(),
    createdAt: z.union([
        z.string(),
        z.null()
    ]).optional(),
    url: z.string().url().optional(),
    description: z.union([
        z.string(),
        z.null()
    ]).optional(),
    author: z.union([
        z.string(),
        z.null()
    ]).optional(),
    publisher: z.union([
        z.string(),
        z.null()
    ]).optional(),
    datePublished: z.union([
        z.string(),
        z.null()
    ]).optional(),
    dateModified: z.union([
        z.string(),
        z.null()
    ]).optional(),
    text: z.union([
        z.string(),
        z.null()
    ]).optional(),
    assetContent: z.union([
        z.string(),
        z.null()
    ]).optional()
});

export const zPatchBookmarksByBookmarkIdParameterBookmarkId = zBookmarkId;

/**
 * The updated bookmark
 */
export const zPatchBookmarksByBookmarkIdResponse = z.object({
    id: z.string(),
    createdAt: z.string(),
    modifiedAt: z.union([
        z.string(),
        z.null()
    ]),
    title: z.union([
        z.string(),
        z.null()
    ]).optional(),
    archived: z.boolean(),
    favourited: z.boolean(),
    taggingStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    summarizationStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    note: z.union([
        z.string(),
        z.null()
    ]).optional(),
    summary: z.union([
        z.string(),
        z.null()
    ]).optional()
});

export const zPostBookmarksByBookmarkIdSummarizeParameterBookmarkId = zBookmarkId;

/**
 * The updated bookmark with summary
 */
export const zPostBookmarksByBookmarkIdSummarizeResponse = z.object({
    id: z.string(),
    createdAt: z.string(),
    modifiedAt: z.union([
        z.string(),
        z.null()
    ]),
    title: z.union([
        z.string(),
        z.null()
    ]).optional(),
    archived: z.boolean(),
    favourited: z.boolean(),
    taggingStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    summarizationStatus: z.enum([
        'success',
        'failure',
        'pending'
    ]),
    note: z.union([
        z.string(),
        z.null()
    ]).optional(),
    summary: z.union([
        z.string(),
        z.null()
    ]).optional()
});

/**
 * The tags to detach.
 */
export const zDeleteBookmarksByBookmarkIdTagsData = z.object({
    tags: z.array(z.object({
        tagId: z.string().optional(),
        tagName: z.string().optional()
    }))
});

export const zDeleteBookmarksByBookmarkIdTagsParameterBookmarkId = zBookmarkId;

/**
 * The list of detached tag ids
 */
export const zDeleteBookmarksByBookmarkIdTagsResponse = z.object({
    detached: z.array(zTagId)
});

/**
 * The tags to attach.
 */
export const zPostBookmarksByBookmarkIdTagsData = z.object({
    tags: z.array(z.object({
        tagId: z.string().optional(),
        tagName: z.string().optional()
    }))
});

export const zPostBookmarksByBookmarkIdTagsParameterBookmarkId = zBookmarkId;

/**
 * The list of attached tag ids
 */
export const zPostBookmarksByBookmarkIdTagsResponse = z.object({
    attached: z.array(zTagId)
});

export const zGetBookmarksByBookmarkIdHighlightsParameterBookmarkId = zBookmarkId;

/**
 * The list of highlights
 */
export const zGetBookmarksByBookmarkIdHighlightsResponse = z.object({
    highlights: z.array(zHighlight)
});

/**
 * The asset to attach
 */
export const zPostBookmarksByBookmarkIdAssetsData = z.object({
    id: z.string(),
    assetType: z.enum([
        'screenshot',
        'assetScreenshot',
        'bannerImage',
        'fullPageArchive',
        'video',
        'bookmarkAsset',
        'precrawledArchive',
        'unknown'
    ])
});

export const zPostBookmarksByBookmarkIdAssetsParameterBookmarkId = zBookmarkId;

/**
 * The attached asset
 */
export const zPostBookmarksByBookmarkIdAssetsResponse = z.object({
    id: z.string(),
    assetType: z.enum([
        'screenshot',
        'assetScreenshot',
        'bannerImage',
        'fullPageArchive',
        'video',
        'bookmarkAsset',
        'precrawledArchive',
        'unknown'
    ])
});

export const zDeleteBookmarksByBookmarkIdAssetsByAssetIdParameterBookmarkId = zBookmarkId;

export const zDeleteBookmarksByBookmarkIdAssetsByAssetIdParameterAssetId = zAssetId;

/**
 * No content - asset was detached successfully
 */
export const zDeleteBookmarksByBookmarkIdAssetsByAssetIdResponse = z.void();

/**
 * The new asset to replace with
 */
export const zPutBookmarksByBookmarkIdAssetsByAssetIdData = z.object({
    assetId: z.string()
});

export const zPutBookmarksByBookmarkIdAssetsByAssetIdParameterBookmarkId = zBookmarkId;

export const zPutBookmarksByBookmarkIdAssetsByAssetIdParameterAssetId = zAssetId;

/**
 * No content - asset was replaced successfully
 */
export const zPutBookmarksByBookmarkIdAssetsByAssetIdResponse = z.void();

/**
 * Object with all lists data.
 */
export const zGetListsResponse = z.object({
    lists: z.array(zList)
});

/**
 * The list to create
 */
export const zPostListsData = z.object({
    name: z.string().min(1).max(40),
    description: z.string().min(0).max(100).optional(),
    icon: z.string(),
    type: z.enum([
        'manual',
        'smart'
    ]).optional(),
    query: z.string().min(1).optional(),
    parentId: z.union([
        z.string(),
        z.null()
    ]).optional()
});

/**
 * The created list
 */
export const zPostListsResponse = zList;

export const zDeleteListsByListIdParameterListId = zListId;

/**
 * No content - the bookmark was deleted
 */
export const zDeleteListsByListIdResponse = z.void();

export const zGetListsByListIdParameterListId = zListId;

/**
 * Object with list data.
 */
export const zGetListsByListIdResponse = zList;

/**
 * The data to update. Only the fields you want to update need to be provided.
 */
export const zPatchListsByListIdData = z.object({
    name: z.string().min(1).max(40).optional(),
    description: z.union([
        z.string().min(0).max(100),
        z.null()
    ]).optional(),
    icon: z.string().optional(),
    parentId: z.union([
        z.string(),
        z.null()
    ]).optional(),
    query: z.string().min(1).optional(),
    public: z.boolean().optional()
});

export const zPatchListsByListIdParameterListId = zListId;

/**
 * The updated list
 */
export const zPatchListsByListIdResponse = zList;

export const zGetListsByListIdBookmarksParameterListId = zListId;

export const zGetListsByListIdBookmarksParameterSortOrder = z.enum([
    'asc',
    'desc'
]);

export const zGetListsByListIdBookmarksParameterLimit = z.number();

export const zGetListsByListIdBookmarksParameterCursor = zCursor;

/**
 * If set to true, bookmark's content will be included in the response. Note, this content can be large for some bookmarks.
 */
export const zGetListsByListIdBookmarksParameterIncludeContent = z.boolean().default(true);

/**
 * Object with list data.
 */
export const zGetListsByListIdBookmarksResponse = zPaginatedBookmarks;

export const zDeleteListsByListIdBookmarksByBookmarkIdParameterListId = zListId;

export const zDeleteListsByListIdBookmarksByBookmarkIdParameterBookmarkId = zBookmarkId;

/**
 * No content - the bookmark was added
 */
export const zDeleteListsByListIdBookmarksByBookmarkIdResponse = z.void();

export const zPutListsByListIdBookmarksByBookmarkIdParameterListId = zListId;

export const zPutListsByListIdBookmarksByBookmarkIdParameterBookmarkId = zBookmarkId;

/**
 * No content - the bookmark was added
 */
export const zPutListsByListIdBookmarksByBookmarkIdResponse = z.void();

/**
 * Object with all tags data.
 */
export const zGetTagsResponse = z.object({
    tags: z.array(zTag)
});

/**
 * The data to create the tag with.
 */
export const zPostTagsData = z.object({
    name: z.string().min(1)
});

/**
 * The created tag
 */
export const zPostTagsResponse = z.object({
    id: z.string(),
    name: z.string()
});

export const zDeleteTagsByTagIdParameterTagId = zTagId;

/**
 * No content - the bookmark was deleted
 */
export const zDeleteTagsByTagIdResponse = z.void();

export const zGetTagsByTagIdParameterTagId = zTagId;

/**
 * Object with list data.
 */
export const zGetTagsByTagIdResponse = zTag;

/**
 * The data to update. Only the fields you want to update need to be provided.
 */
export const zPatchTagsByTagIdData = z.object({
    name: z.string().optional()
});

export const zPatchTagsByTagIdParameterTagId = zTagId;

/**
 * The updated tag
 */
export const zPatchTagsByTagIdResponse = z.object({
    id: z.string(),
    name: z.string()
});

export const zGetTagsByTagIdBookmarksParameterTagId = zTagId;

export const zGetTagsByTagIdBookmarksParameterSortOrder = z.enum([
    'asc',
    'desc'
]);

export const zGetTagsByTagIdBookmarksParameterLimit = z.number();

export const zGetTagsByTagIdBookmarksParameterCursor = zCursor;

/**
 * If set to true, bookmark's content will be included in the response. Note, this content can be large for some bookmarks.
 */
export const zGetTagsByTagIdBookmarksParameterIncludeContent = z.boolean().default(true);

/**
 * Object with list data.
 */
export const zGetTagsByTagIdBookmarksResponse = zPaginatedBookmarks;

export const zGetHighlightsParameterLimit = z.number();

export const zGetHighlightsParameterCursor = zCursor;

/**
 * Object with all highlights data.
 */
export const zGetHighlightsResponse = zPaginatedHighlights;

/**
 * The highlight to create
 */
export const zPostHighlightsData = z.object({
    bookmarkId: z.string(),
    startOffset: z.number(),
    endOffset: z.number(),
    color: z.enum([
        'yellow',
        'red',
        'green',
        'blue'
    ]).optional(),
    text: z.union([
        z.string(),
        z.null()
    ]),
    note: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * The created highlight
 */
export const zPostHighlightsResponse = zHighlight;

export const zDeleteHighlightsByHighlightIdParameterHighlightId = zHighlightId;

/**
 * The deleted highlight
 */
export const zDeleteHighlightsByHighlightIdResponse = zHighlight;

export const zGetHighlightsByHighlightIdParameterHighlightId = zHighlightId;

/**
 * Object with highlight data.
 */
export const zGetHighlightsByHighlightIdResponse = zHighlight;

/**
 * The data to update. Only the fields you want to update need to be provided.
 */
export const zPatchHighlightsByHighlightIdData = z.object({
    color: z.enum([
        'yellow',
        'red',
        'green',
        'blue'
    ]).optional()
});

export const zPatchHighlightsByHighlightIdParameterHighlightId = zHighlightId;

/**
 * The updated highlight
 */
export const zPatchHighlightsByHighlightIdResponse = zHighlight;

/**
 * Object with user data.
 */
export const zGetUsersMeResponse = z.object({
    id: z.string(),
    name: z.union([
        z.string(),
        z.null()
    ]).optional(),
    email: z.union([
        z.string(),
        z.null()
    ]).optional()
});

/**
 * Object with user stats.
 */
export const zGetUsersMeStatsResponse = z.object({
    numBookmarks: z.number(),
    numFavorites: z.number(),
    numArchived: z.number(),
    numTags: z.number(),
    numLists: z.number(),
    numHighlights: z.number()
});

/**
 * The data to create the asset with.
 */
export const zPostAssetsData = z.object({
    file: zFileToBeUploaded
});

/**
 * Details about the created asset
 */
export const zPostAssetsResponse = zAsset;

export const zGetAssetsByAssetIdParameterAssetId = zAssetId;
